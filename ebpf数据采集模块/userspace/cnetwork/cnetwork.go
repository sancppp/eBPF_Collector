package cnetwork

import (
	"bytes"
	"ebpf_exporter/event"
	"ebpf_exporter/util"
	"encoding/binary"
	"encoding/json"
	"errors"
	"log"
	"net"
	"net/http"
	"strings"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"golang.org/x/sys/unix"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target amd64 -type cnetwork_event bpf ../../kern/containernet.c -- -I../../kern/headers
func InitCNetwork(stopper <-chan struct{}, eventCh chan<- event.IEvent) {
	// Load pre-compiled programs and maps into the kernel.
	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		log.Fatalf("loading objects: %v", err)
	}
	defer objs.Close()
	kretp, err := link.Kretprobe("sock_alloc", objs.KretprobeSockAllocRet, nil)
	if err != nil {
		log.Fatalf("opening kretprobe: %s", err)
	}
	defer kretp.Close()
	kp1, err := link.Kprobe("__tcp_transmit_skb", objs.KprobeTcpTransmitSkb, nil)
	if err != nil {
		log.Fatalf("opening kprobe: %s", err)
	}
	defer kp1.Close()
	kp2, err := link.Kprobe("tcp_v4_do_rcv", objs.KprobeTcpV4DoRcv, nil)
	if err != nil {
		log.Fatalf("opening kprobe: %s", err)
	}
	defer kp2.Close()

	rd, err := ringbuf.NewReader(objs.ContainernetRb)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()
	log.Println("Waiting for cnetwork events..")

	go func() {
		// clean
		http.HandleFunc("/cnetworkclean", func(w http.ResponseWriter, r *http.Request) {
			// 清空所有的黑名单
			it := objs.CnetworkBanned.Iterate()
			var ipkey uint64
			var ipval uint8
			var ipkeys []uint64
			for it.Next(&ipkey, &ipval) {
				ipkeys = append(ipkeys, ipkey)
			}
			for _, ipkey := range ipkeys {
				if err := objs.CnetworkBanned.Delete(&ipkey); err != nil {
					log.Println(err)
				}
			}

			// 将清空的 IP 地址列表转换为 JSON 并作为响应返回
			w.Header().Set("Content-Type", "application/json")
			if err := json.NewEncoder(w).Encode(ipkeys); err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		})

		// cnetworkconfig?sip=172.24.0.2&dip=172.24.0.2
		http.HandleFunc("/cnetworkconfig", func(w http.ResponseWriter, r *http.Request) {
			sip := r.URL.Query().Get("sip")
			dip := r.URL.Query().Get("dip")

			if sip == "" || dip == "" {
				http.Error(w, "Missing sip or dip parameter", http.StatusBadRequest)
				return
			}

			// 将形如172.24.0.2的IP地址先反转，再转换成uint32
			sip32 := ipToReversedUint32(sip)
			dip32 := ipToReversedUint32(dip)
			var ipkey uint64 = uint64(sip32)<<32 | uint64(dip32)
			var ipval uint8 = 1
			if err := objs.CnetworkBanned.Update(&ipkey, &ipval, ebpf.UpdateAny); err != nil {
				log.Println(err)
			}
			w.Write([]byte("ok"))
		})

		log.Println("Starting cnetwork config server on :8889")
		if err := http.ListenAndServe(":8889", nil); err != nil {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	go func() {
		// bpfEvent is generated by bpf2go.
		var bpfevent bpfCnetworkEvent
		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, ringbuf.ErrClosed) {
					log.Println("Received signal, exiting..")
					return
				}
				log.Printf("reading from reader: %s", err)
				continue
			}
			// Parse the ringbuf event entry into a bpfEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &bpfevent); err != nil {
				log.Printf("parsing ringbuf event: %s", err)
				continue
			}

			if bpfevent.Saddr == 0 || bpfevent.Daddr == 0 {
				continue //脏数据
			}
			// 打印 bpfEvent 结构体的内容
			networkevent := event.CNetwork_event{
				Type:          "Network_event",
				Timestamp:     bpfevent.Timestamp,
				Pid:           bpfevent.Pid,
				Comm:          unix.ByteSliceToString(bpfevent.Comm[:]),
				Cid:           unix.ByteSliceToString(bpfevent.Cid[:]),
				ContainerName: util.GetContainerName(unix.ByteSliceToString(bpfevent.Cid[:])),
				Flag:          bpfevent.Flag,
				Daddr:         [4]byte{byte(bpfevent.Daddr), byte(bpfevent.Daddr >> 8), byte(bpfevent.Daddr >> 16), byte(bpfevent.Daddr >> 24)},
				Dport:         bpfevent.Dport,
				Saddr:         [4]byte{byte(bpfevent.Saddr), byte(bpfevent.Saddr >> 8), byte(bpfevent.Saddr >> 16), byte(bpfevent.Saddr >> 24)},
				Sport:         bpfevent.Sport,
			}
			// fmt.Printf("networkevent: %v\n", networkevent)
			eventCh <- networkevent
		}
	}()

	<-stopper
}

func ipToReversedUint32(ipStr string) uint32 {
	// 拆分IP地址成四个部分
	parts := strings.Split(ipStr, ".")
	if len(parts) != 4 {
		return 0 // 无效的IP地址返回0
	}

	// 反转这些部分
	reversedParts := []string{parts[3], parts[2], parts[1], parts[0]}

	// 将反转后的部分重新组合成新的IP地址字符串
	reversedIPStr := strings.Join(reversedParts, ".")

	// 将新的IP地址字符串转换成net.IP类型
	reversedIP := net.ParseIP(reversedIPStr).To4()
	if reversedIP == nil {
		return 0 // 无效的IP地址返回0
	}

	// 将net.IP类型转换成uint32
	return binary.BigEndian.Uint32(reversedIP)
}
